
## parse 
## https://www.unicode.org/Public/UCD/latest/ucd/CaseFolding.txt
## 
## 
## We use status of C and F, excluding T

when not defined(ssl):
  {.error: "compile using -d:ssl, or change CaseFoldingTxtUrl to `http` scheme".}
import std/os
const
  CurSourcePath = currentSourcePath()
  CurSourceDir = CurSourcePath.parentDir()
  CurSourceName = CurSourcePath.lastPathPart()

const
  CaseFoldingTxtUrl{.strdefine.} ="https://www.unicode.org/Public/UCD/latest/ucd/CaseFolding.txt"
  outfile{.strdefine.} = slurp(CurSourceDir/"unicase_outdir.txt") / "casefoldMapper.nim"

import std/unicode
import std/strutils
import std/parseutils
import std/streams
type
  RuneI = int32

var
  CommonMapper: seq[(RuneI, RuneI)]
  FullMapper: seq[(RuneI, string)]

template assume(cond) =
  when not defined(release):
    assert cond

proc parse(s: Stream) =
  var
    code, mapping1: RuneI
    mappingStr: string
  for line in s.lines:
    if line.len == 0 or line[0] == '#': continue

    let ls = line.split(';')
    let (codeS, statusS, mappingS) = (ls[0], ls[1], ls[2])

    var parseRet: int
    template getHex(i: int, s: string, start=0) =
      parseRet = parseHex(s, i, start)
      assume parseRet != 0

    code.getHex codeS
    assume statusS[0] == ' ' and mappingS[0] == ' '
    let status = statusS[1]

    case status
    of 'C':
      mapping1.getHex(mappingS, 1)
      CommonMapper.add (code, mapping1)
    of 'F':
      let ls = mappingS.split(' ')
      assume ls[0].len == 0
      mappingStr.setLen 0
      for i in 1..<ls.len:
        mappingStr.add Rune parseHexInt ls[i]
      FullMapper.add (code, mappingStr)
    else: discard

template asLit[T](s: T): string =
  when T is string: '"' & s & '"'
  elif T is RuneI: $s & "'i32"
  else: $s

proc dumpTableLitImpl[K, V](sequ: seq[(K, V)], s: Stream) =
  #s.writeLine "import std/tables"
  s.write "{\n"
  for tup in sequ:
    s.writeLine "  ", tup[0].asLit, ": ", tup[1].asLit, ','
  s.write "}"

template dumpTableLit[K, V](sequ: seq[(K, V)], s: Stream) =
  s.write "const " & astToStr(sequ) & " = "
  sequ.dumpTableLitImpl s
  s.write '\n'

proc dumpData(s: Stream) =
  s.writeLine "# Generated by /tools/unicodedata/" & CurSourceName
  s.writeLine "# where `/` refers to the root path of this project."
  s.writeLine "# to be included."
  CommonMapper.dumpTableLit s
  FullMapper.dumpTableLit s

when isMainModule:
  import std/httpclient
  var client = newHttpClient()
  let resp = client.get CaseFoldingTxtUrl
  var stream = resp.bodyStream
  parse stream

  var outStream = newFileStream(outfile, fmWrite)
  dumpData outStream
  outStream.close()

  client.close()



  




